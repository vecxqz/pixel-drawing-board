<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      html,
      body {
        padding: 0;
        margin: 0;
      }
      .btn-group-operator {
        margin-top: 10px;
        display: flex;
      }
      .btn-operator {
        display: flex;
        justify-content: center;
        width: 200px;
        padding: 10px;
        border-radius: 4px;
        background: rgb(255, 220, 220);
      }
      .btn-operator:last-of-type {
        margin-left: 10px;
      }
      .box {
        display: flex;
      }
      .tools {
        margin-left: 10px;
      }
      ul {
        padding: 0;
        list-style: none;
      }
      .color-choose ul {
        display: flex;
      }
      .color-choose ul li {
        border: 1px solid rgba(218, 216, 216, 0.567);
        border-radius: 4px;
        margin-right: 10px;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div class="box">
        <canvas
          ref="canvas"
          :width="board.width"
          :height="board.height"
        ></canvas>
        <div class="tools">
          <p>当前在线</p>
          <ul>
            <li v-for="user in userList">{{user}}</li>
          </ul>
          <div class="color-choose">
            <ul>
              <li
                v-for="color in colors"
                :style="{backgroundColor:color,height:'30px',width:'30px'}"
                @click="colorSetByChoose(color)"
              />
            </ul>
          </div>
          <div class="btn-group-operator">
            <div class="btn-operator" @click="redo()">redo</div>
            <div class="btn-operator" @click="undo()">undo</div>
          </div>
        </div>
      </div>
    </div>
  </body>
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://unpkg.com/vue@next"></script>
  <script>
    let app = {
      data() {
        return {
          mouseDown: false,
          ctx: null,
          board: {
            width: 1200,
            height: 900,
            gridSize: 10,
            rowCount: 0,
            columnCount: 0,
            gridMeta: [],
            operatorStack: [],
            operatorPopStack: [],
            color: "black",
            tempStack: []
          },
          userListData: [],
          socket: null,
          colors: ["red", "yellow", "blue", "green", "black", "white"]
        };
      },
      mounted() {
        const { canvas } = this.$refs;
        this.socket = io();
        this.ctx = canvas.getContext("2d");
        this.boardInit();
        this.$refs.canvas.addEventListener(
          "mousedown",
          function (e) {
            this.board.tempStack = [];
            this.mouseDown = true;
            this.draw(e);
            this.$refs.canvas.addEventListener(
              "mousemove",
              this.handleMouseMove
            );
          }.bind(this)
        );
        this.$refs.canvas.addEventListener(
          "mouseup",
          function (e) {
            this.mouseDown = false;
            this.board.operatorStack.push(this.board.tempStack);
            this.$refs.canvas.removeEventListener(
              "mousemove",
              this.handleMouseMove
            );
          }.bind(this)
        );
        this.socket.on("message", data => {
          console.log(data);
          if (data.type === "update") {
            const { xIndex, yIndex, gridMeta } = data;
            console.log(data);
            this.board.gridMeta[xIndex][yIndex] = gridMeta;
            this.drawGridBySocket(xIndex, yIndex);
          }
          if (data.type === "userAdd") {
            const { data: userData } = data;
            this.userListData= userData;
          }
          if (data.type === "userRemove") {
            const { data: userData } = data;
            this.userListData= userData;
          }
        });
      },
      methods: {
        boardInit() {
          for (
            let column = 0;
            column < Math.floor(this.board.width / this.board.gridSize);
            column += 1
          ) {
            for (
              let row = 0;
              row < Math.floor(this.board.height / this.board.gridSize);
              row += 1
            ) {
              const size = this.board.gridSize;
              const x = column * size;
              const y = row * size;
              const columnIndex = column;
              const rowIndex = row;
              if (!Array.isArray(this.board.gridMeta[columnIndex])) {
                this.board.gridMeta[columnIndex] = [];
              }
              // 奇数行奇数列
              if (rowIndex % 2 !== 0 && columnIndex % 2 !== 0) {
                this.ctx.fillStyle = "#ffffff";
                this.ctx.fillRect(x, y, size, size);
                this.board.gridMeta[columnIndex][rowIndex] = {
                  columnIndex: columnIndex,
                  rowIndex: rowIndex,
                  x: x,
                  y: y,
                  size: size,
                  gridBoardColor: "#ffffff"
                };
              }
              // 奇数行偶数列
              if (rowIndex % 2 !== 0 && columnIndex % 2 === 0) {
                this.ctx.fillStyle = "#d9d9d9";
                this.ctx.fillRect(x, y, size, size);
                this.board.gridMeta[columnIndex][rowIndex] = {
                  columnIndex: columnIndex,
                  rowIndex: rowIndex,
                  x: x,
                  y: y,
                  size: size,
                  gridBoardColor: "#d9d9d9"
                };
              }
              // 偶数行奇数列
              if (rowIndex % 2 === 0 && columnIndex % 2 !== 0) {
                this.ctx.fillStyle = "#d9d9d9";
                this.ctx.fillRect(x, y, size, size);
                this.board.gridMeta[columnIndex][rowIndex] = {
                  columnIndex: columnIndex,
                  rowIndex: rowIndex,
                  x: x,
                  y: y,
                  size: size,
                  gridBoardColor: "#d9d9d9"
                };
              }
              // 偶数行偶数列
              if (rowIndex % 2 === 0 && columnIndex % 2 === 0) {
                this.ctx.fillStyle = "#ffffff";
                this.ctx.fillRect(x, y, size, size);
                this.board.gridMeta[columnIndex][rowIndex] = {
                  columnIndex: columnIndex,
                  rowIndex: rowIndex,
                  x: x,
                  y: y,
                  size: size,
                  gridBoardColor: "#ffffff"
                };
              }
            }
          }
        },
        setGridColor(gridMeta) {
          const { gridColor, gridBoardColor } = gridMeta;
          this.ctx.fillStyle = gridColor ? gridColor : gridBoardColor;
        },
        getGridColor(gridMeta) {
          const { gridColor, gridBoardColor } = gridMeta;
          return gridColor ? gridColor : gridBoardColor;
        },
        drawGridBySocket(columnIndex, rowIndex) {
          const { x, y, size, gridColor, gridBoardColor } = this.board.gridMeta[
            columnIndex
          ][rowIndex];
          this.ctx.fillStyle = gridColor ? gridColor : gridBoardColor;
          this.ctx.fillRect(x, y, size, size);
        },
        drawGrid(columnIndex, rowIndex) {
          const { x, y, size } = this.board.gridMeta[columnIndex][rowIndex];
          this.ctx.fillRect(x, y, size, size);
        },
        handleMouseMove(e) {
          this.draw(e);
        },
        draw(e) {
          let xIndex = Math.floor(e.clientX / this.board.gridSize);
          let yIndex = Math.floor(e.clientY / this.board.gridSize);
          let x = xIndex * this.board.gridSize;
          let y = yIndex * this.board.gridSize;
          this.ctx.fillStyle = this.board.color;
          this.ctx.fillRect(x, y, this.board.gridSize, this.board.gridSize);
          // 记录连续绘制的点
          let result = this.board.tempStack.filter(
            operator => operator.x === x && operator.y === y
          );
          if (result.length === 0) {
            this.board.tempStack.push(this.board.gridMeta[xIndex][yIndex]);
          }
          this.board.gridMeta[xIndex][yIndex] = {
            ...this.board.gridMeta[xIndex][yIndex],
            gridColor: this.board.color
          };
          this.socket.emit("message", {
            type: "update",
            xIndex,
            yIndex,
            gridMeta: this.board.gridMeta[xIndex][yIndex]
          });
        },
        redo() {
          const operators = this.board.operatorStack.pop();
          if (!operators) return;
          const newOperators = operators.map(operator => {
            const { columnIndex, rowIndex } = operator;
            const gridColor = this.getGridColor(operator);
            const tempGird = { ...this.board.gridMeta[columnIndex][rowIndex] };
            this.setGridColor(operator);
            this.drawGrid(columnIndex, rowIndex);
            // 更新元数据
            this.board.gridMeta[columnIndex][rowIndex] = {
              ...this.board.gridMeta[columnIndex][rowIndex],
              gridColor: gridColor
            };
            return {
              ...operator,
              ...tempGird
            };
          });
          this.board.operatorPopStack.push(newOperators);
        },
        undo() {
          const operators = this.board.operatorPopStack.pop();
          if (!operators) return;
          const newOperators = operators.map(operator => {
            const { rowIndex, columnIndex } = operator;
            const gridColor = this.getGridColor(operator);
            const tempGird = { ...this.board.gridMeta[columnIndex][rowIndex] };
            this.setGridColor(operator);
            this.drawGrid(columnIndex, rowIndex);
            // 更新元数据
            this.board.gridMeta[columnIndex][rowIndex] = {
              ...this.board.gridMeta[columnIndex][rowIndex],
              gridColor: gridColor
            };
            return {
              ...operator,
              ...tempGird
            };
          });
          this.board.operatorStack.push(newOperators);
        },
        colorSetByChoose(color) {
          this.board.color = color;
        }
      },
      computed: {
        userList() {
          return this.userListData;
        }
      }
    };
    let vm = Vue.createApp(app).mount("#app");
  </script>
</html>
