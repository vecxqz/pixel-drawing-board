<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      html,
      body {
        padding: 0;
        margin: 0;
      }
      .btn-group-operator {
        margin-top: 10px;
        display: flex;
      }
      .btn-operator {
        display: flex;
        justify-content: center;
        width: 200px;
        padding: 10px;
        border-radius: 4px;
        background: rgb(255, 220, 220);
      }
      .btn-operator:last-of-type {
        margin-left: 10px;
      }
      .box {
        display: flex;
      }
      .tools {
        margin-left: 10px;
      }
      ul {
        padding: 0;
        list-style: none;
      }
      .color-choose ul {
        display: flex;
      }
      .color-choose ul li {
        border: 1px solid rgba(218, 216, 216, 0.567);
        border-radius: 4px;
        margin-right: 10px;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div class="box">
        <canvas
          ref="canvas"
          :width="board.width"
          :height="board.height"
        ></canvas>
        <div class="tools">
          <p>当前在线</p>
          <ul>
            <li v-for="user in userList">{{user}}</li>
          </ul>
          <div class="color-choose">
            <ul>
              <li
                v-for="color in colors"
                :style="{backgroundColor:color,height:'30px',width:'30px'}"
                @click="colorSetByChoose(color)"
              />
            </ul>
          </div>
          <div class="btn-group-operator">
            <div class="btn-operator" @click="redo()">redo</div>
            <div class="btn-operator" @click="undo()">undo</div>
          </div>
        </div>
      </div>
    </div>
  </body>
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://unpkg.com/vue@next"></script>
  <script>
    let app = {
      data() {
        return {
          mouseDown: false,
          ctx: null,
          board: {
            width: 600,
            height: 600,
            gridSize: 10,
            rowCount: 0,
            columnCount: 0,
            gridMeta: [],
            operatorStack: [],
            operatorPopStack: [],
            color: "black",
            tempStack: [],
            startPoint: { e: null, x: null, y: null },
            endPoint: { e: null, x: null, y: null },
            lastStartPoint: { e: null, x: null, y: null },
            lastEndPoint: { e: null, x: null, y: null }
          },
          userListData: [],
          socket: null,
          colors: ["red", "yellow", "blue", "green", "black", "white"],
          // mode: "line",
          mode: "point"
        };
      },
      mounted() {
        const { canvas } = this.$refs;
        this.socket = io();
        this.ctx = canvas.getContext("2d");
        this.boardInit();
        this.$refs.canvas.addEventListener(
          "mousedown",
          function (e) {
            this.board.tempStack = [];
            this.mouseDown = true;
            this.board.startPoint.e = e;
            this.board.lastStartPoint.x = null;
            this.board.lastStartPoint.y = null;
            this.board.lastEndPoint.x = null;
            this.board.lastEndPoint.y = null;
            this.$refs.canvas.addEventListener(
              "mousemove",
              this.handleMouseMove
            );
          }.bind(this)
        );
        this.$refs.canvas.addEventListener(
          "mouseup",
          function (e) {
            this.mouseDown = false;
            this.board.operatorStack.push(this.board.tempStack);
            this.$refs.canvas.removeEventListener(
              "mousemove",
              this.handleMouseMove
            );
          }.bind(this)
        );
        this.socket.on("message", data => {
          console.log(data);
          if (data.type === "update") {
            const { xIndex, yIndex, gridMeta } = data;
            console.log(data);
            this.board.gridMeta[xIndex][yIndex] = gridMeta;
            this.drawGridBySocket(xIndex, yIndex);
          }
          if (data.type === "userAdd") {
            const { data: userData } = data;
            this.userListData = userData;
          }
          if (data.type === "userRemove") {
            const { data: userData } = data;
            this.userListData = userData;
          }
        });
      },
      methods: {
        boardInit() {
          for (
            let column = 0;
            column < Math.floor(this.board.width / this.board.gridSize);
            column += 1
          ) {
            for (
              let row = 0;
              row < Math.floor(this.board.height / this.board.gridSize);
              row += 1
            ) {
              const size = this.board.gridSize;
              const x = column * size;
              const y = row * size;
              const columnIndex = column;
              const rowIndex = row;
              if (!Array.isArray(this.board.gridMeta[columnIndex])) {
                this.board.gridMeta[columnIndex] = [];
              }
              // 奇数行奇数列
              if (rowIndex % 2 !== 0 && columnIndex % 2 !== 0) {
                this.ctx.fillStyle = "#ffffff";
                this.ctx.fillRect(x, y, size, size);
                this.board.gridMeta[columnIndex][rowIndex] = {
                  columnIndex: columnIndex,
                  rowIndex: rowIndex,
                  x: x,
                  y: y,
                  size: size,
                  gridBoardColor: "#ffffff"
                };
              }
              // 奇数行偶数列
              if (rowIndex % 2 !== 0 && columnIndex % 2 === 0) {
                this.ctx.fillStyle = "#d9d9d9";
                this.ctx.fillRect(x, y, size, size);
                this.board.gridMeta[columnIndex][rowIndex] = {
                  columnIndex: columnIndex,
                  rowIndex: rowIndex,
                  x: x,
                  y: y,
                  size: size,
                  gridBoardColor: "#d9d9d9"
                };
              }
              // 偶数行奇数列
              if (rowIndex % 2 === 0 && columnIndex % 2 !== 0) {
                this.ctx.fillStyle = "#d9d9d9";
                this.ctx.fillRect(x, y, size, size);
                this.board.gridMeta[columnIndex][rowIndex] = {
                  columnIndex: columnIndex,
                  rowIndex: rowIndex,
                  x: x,
                  y: y,
                  size: size,
                  gridBoardColor: "#d9d9d9"
                };
              }
              // 偶数行偶数列
              if (rowIndex % 2 === 0 && columnIndex % 2 === 0) {
                this.ctx.fillStyle = "#ffffff";
                this.ctx.fillRect(x, y, size, size);
                this.board.gridMeta[columnIndex][rowIndex] = {
                  columnIndex: columnIndex,
                  rowIndex: rowIndex,
                  x: x,
                  y: y,
                  size: size,
                  gridBoardColor: "#ffffff"
                };
              }
            }
          }
        },
        setGridColor(gridMeta) {
          const { gridColor, gridBoardColor } = gridMeta;
          this.ctx.fillStyle = gridColor ? gridColor : gridBoardColor;
        },
        clearGrid(x, y) {
          const color = this.getColorToDefalut(x, y);
          this.drawGrid(x, y, color);
        },
        getColorToDefalut(x, y) {
          return this.getGridColor(this.board.gridMeta[x][y]);
        },
        getGridColor(gridMeta) {
          const { gridColor, gridBoardColor } = gridMeta;
          return gridColor ? gridColor : gridBoardColor;
        },
        drawGridBySocket(columnIndex, rowIndex) {
          const { x, y, size, gridColor, gridBoardColor } = this.board.gridMeta[
            columnIndex
          ][rowIndex];
          this.ctx.fillStyle = gridColor ? gridColor : gridBoardColor;
          this.ctx.fillRect(x, y, size, size);
        },
        drawGrid(columnIndex, rowIndex, color) {
          const { x, y, size } = this.board.gridMeta[columnIndex][rowIndex];
          this.ctx.fillStyle = color;
          this.ctx.fillRect(x, y, size, size);
        },
        handleMouseMove(e) {
          this.board.endPoint.e = e;
          if (this.mode === "point") {
            this.draw(e);
          }
          if (this.mode === "line") {
            let x1, y1, x2, y2;
            x1 = Math.floor(
              this.board.startPoint.e.clientX / this.board.gridSize
            );
            y1 = Math.floor(
              this.board.startPoint.e.clientY / this.board.gridSize
            );
            x2 = Math.floor(
              this.board.endPoint.e.clientX / this.board.gridSize
            );
            y2 = Math.floor(
              this.board.endPoint.e.clientY / this.board.gridSize
            );
            const { x: x3, y: y3 } = this.board.lastStartPoint;
            const { x: x4, y: y4 } = this.board.lastEndPoint;
            console.log(x3, y3, x4, y4);
            if (x3 !== null && y3 !== null && (x4 !== null) & (y4 !== null)) {
              this.bresenhamLine(x3, y3, x4, y4, this.clearGrid);
            }
            this.ctx.fillStyle = "black";
            this.bresenhamLine(x1, y1, x2, y2, this.drawGrid);
            this.board.lastStartPoint.x = x1;
            this.board.lastStartPoint.y = y1;
            this.board.lastEndPoint.x = x2;
            this.board.lastEndPoint.y = y2;
          }
        },
        draw(e) {
          let xIndex = Math.floor(e.clientX / this.board.gridSize);
          let yIndex = Math.floor(e.clientY / this.board.gridSize);
          let x = xIndex * this.board.gridSize;
          let y = yIndex * this.board.gridSize;
          this.ctx.fillStyle = this.board.color;
          this.ctx.fillRect(x, y, this.board.gridSize, this.board.gridSize);
          // 记录连续绘制的点
          let result = this.board.tempStack.filter(
            operator => operator.x === x && operator.y === y
          );
          if (result.length === 0) {
            this.board.tempStack.push(this.board.gridMeta[xIndex][yIndex]);
          }
          this.board.gridMeta[xIndex][yIndex] = {
            ...this.board.gridMeta[xIndex][yIndex],
            gridColor: this.board.color
          };
          this.socket.emit("message", {
            type: "update",
            xIndex,
            yIndex,
            gridMeta: this.board.gridMeta[xIndex][yIndex]
          });
        },
        redo() {
          const operators = this.board.operatorStack.pop();
          if (!operators) return;
          const newOperators = operators.map(operator => {
            const { columnIndex, rowIndex } = operator;
            const gridColor = this.getGridColor(operator);
            const tempGird = { ...this.board.gridMeta[columnIndex][rowIndex] };
            const color = this.getGridColor(operator);
            this.drawGrid(columnIndex, rowIndex, color);
            // 更新元数据
            this.board.gridMeta[columnIndex][rowIndex] = {
              ...this.board.gridMeta[columnIndex][rowIndex],
              gridColor: gridColor
            };
            return {
              ...operator,
              ...tempGird
            };
          });
          this.board.operatorPopStack.push(newOperators);
        },
        undo() {
          const operators = this.board.operatorPopStack.pop();
          if (!operators) return;
          const newOperators = operators.map(operator => {
            const { rowIndex, columnIndex } = operator;
            const gridColor = this.getGridColor(operator);
            const tempGird = { ...this.board.gridMeta[columnIndex][rowIndex] };
            const color = this.getGridColor(operator);
            this.drawGrid(columnIndex, rowIndex, color);
            // 更新元数据
            this.board.gridMeta[columnIndex][rowIndex] = {
              ...this.board.gridMeta[columnIndex][rowIndex],
              gridColor: gridColor
            };
            return {
              ...operator,
              ...tempGird
            };
          });
          this.board.operatorStack.push(newOperators);
        },
        colorSetByChoose(color) {
          this.board.color = color;
        },
        bresenhamLine(x1, y1, x2, y2, callback, color) {
          var w = x2 - x1;
          var h = y2 - y1;
          var dx = ((w > 0) << 1) - 1;
          var dy = ((h > 0) << 1) - 1;
          w = Math.abs(w);
          h = Math.abs(h);
          var f, y, x, delta1, delta2;
          if (w > h) {
            f = 2 * h - w;
            delta1 = 2 * h;
            delta2 = (h - w) * 2;
            for (x = x1, y = y1; x != x2; x += dx) {
              callback(x, y, color);
              if (f < 0) {
                f += delta1;
              } else {
                y += dy;
                f += delta2;
              }
            }
            callback(x, y, color);
          } else {
            f = 2 * w - h;
            delta1 = w * 2;
            delta2 = (w - h) * 2;
            for (x = x1, y = y1; y != y2; y += dy) {
              callback(x, y, color);
              if (f < 0) {
                f += delta1;
              } else {
                x += dx;
                f += delta2;
              }
            }
            callback(x, y, color);
          }
        }
      },
      computed: {
        userList() {
          return this.userListData;
        }
      }
    };
    let vm = Vue.createApp(app).mount("#app");
  </script>
</html>
